import { DMMF } from "@prisma/generator-helper";
import { MermaidWriter } from "./MermaidWriter";
import { DescriptionWriter } from "./DescriptionWriter";
import { MapUtil } from "../utils/MapUtil";
import { ITagSection } from "../structure/ITagSection";

export namespace MarkdownWriter {
    export const write = (schema: DMMF.Datamodel): string => {
        const dict: Map<string, ITagSection> = new Map();
        for (const model of schema.models) {
            const pair: ITagPair = getTagPairs(model);
            if (pair.models.size === 0)
                MapUtil.take(dict)("default", () => ({
                    name: "default",
                    models: [],
                    erdOnly: [],
                })).models.push(model);
            for (const name of pair.models)
                MapUtil.take(dict)(name, () => ({
                    name,
                    models: [],
                    erdOnly: [],
                })).models.push(model);
            for (const name of pair.erdOnly)
                MapUtil.take(dict)(name, () => ({
                    name,
                    models: [],
                    erdOnly: [],
                })).erdOnly.push(model);
        }
        const preface: string = [
            `# Prisma Markdown`,
            "Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)",
        ].join("\n");
        return (
            preface + "\n\n" + [...dict.values()].map(writeTag).join("\n\n\n")
        );
    };

    const getTagPairs = (model: DMMF.Model): ITagPair => {
        const pair: ITagPair = {
            models: new Set(),
            erdOnly: new Set(),
        };
        if (!model.documentation?.length) return pair;

        const splitted: string[] = model.documentation
            .split("\r\n")
            .join("\n")
            .split("\n");
        for (const symbol of ["tag", "erdTag"]) {
            const set: Set<string> =
                symbol === "tag" ? pair.models : pair.erdOnly;
            for (const line of splitted) {
                const first: number = line.indexOf(`@${symbol} `);
                if (first === -1) continue;

                const last: number = line.indexOf(" ", symbol.length + 2);
                set.add(
                    last === -1
                        ? line.slice(first + symbol.length + 2)
                        : line.slice(first + symbol.length + 2, last),
                );
            }
        }
        return pair;
    };

    const writeTag = (section: ITagSection): string =>
        [
            `## ${section.name}`,
            MermaidWriter.write(section),
            "",
            section.models.map(DescriptionWriter.table).join("\n\n"),
        ].join("\n");
}

interface ITagPair {
    models: Set<string>;
    erdOnly: Set<string>;
}

import { DMMF } from "@prisma/generator-helper";
import { MermaidWriter } from "./MermaidWriter";
import { DescriptionWriter } from "./DescriptionWriter";
import { MapUtil } from "../utils/MapUtil";
import { ITagSection } from "../structure/ITagSection";

export namespace MarkdownWriter {
    export const write = (schema: DMMF.Datamodel): string => {
        const dict: Map<string, ITagSection> = new Map();
        for (const model of schema.models) {
            const tags: string[] = takeTags("tag")(model);
            if (tags.length === 0)
                MapUtil.take(dict)("default", () => ({
                    name: "default",
                    models: [],
                    erdOnly: [],
                })).models.push(model);
            else
                for (const name of tags)
                    MapUtil.take(dict)(name, () => ({
                        name,
                        models: [],
                        erdOnly: [],
                    })).models.push(model);
        }
        for (const model of schema.models)
            for (const name of takeTags("erdTag")(model))
                MapUtil.take(dict)(name, () => ({
                    name,
                    models: [],
                    erdOnly: [],
                })).erdOnly.push(model);

        const preface: string = [
            `# Prisma Markdown`,
            "Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)",
        ].join("\n");
        return (
            preface +
            "\n\n" +
            [...dict.values()]
                .filter((s) => !!s.models.length)
                .map(writeTag)
                .join("\n\n\n")
        );
    };

    const takeTags =
        (kind: "tag" | "erdTag") =>
        (model: DMMF.Model): string[] => {
            if (!model.documentation?.length) return [];

            const output: Set<string> = new Set();
            const splitted: string[] = model.documentation
                .split("\r\n")
                .join("\n")
                .split("\n");
            for (const line of splitted) {
                const first: number = line.indexOf(`@${kind} `);
                if (first === -1) continue;

                const last: number = line.indexOf(" ", kind.length + 2);
                output.add(
                    last === -1
                        ? line.slice(first + kind.length + 2)
                        : line.slice(first + kind.length + 2, last),
                );
            }
            return [...output];
        };

    const writeTag = (section: ITagSection): string =>
        [
            `## ${section.name}`,
            MermaidWriter.write(section),
            "",
            section.models.map(DescriptionWriter.table).join("\n\n"),
        ].join("\n");
}

interface ITagPair {
    models: Set<string>;
    erdOnly: Set<string>;
}
